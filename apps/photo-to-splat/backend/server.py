"""
Photo-to-Splat API Server
Uses Apple's SHARP model to convert single images to 3D Gaussian Splats
"""

import os
import io
import uuid
import subprocess
import tempfile
from pathlib import Path
from datetime import datetime


def log(job_id: str, message: str):
    """Print timestamped log message."""
    ts = datetime.now().strftime("%H:%M:%S")
    print(f"[{ts}] [{job_id}] {message}")


from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from fastapi.staticfiles import StaticFiles

app = FastAPI(title="Photo to Splat API")

# CORS for local frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:5173",
        "http://localhost:3000",
        "http://127.0.0.1:5173",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Directory for output splats
OUTPUT_DIR = Path(__file__).parent / "outputs"
OUTPUT_DIR.mkdir(exist_ok=True)

# Serve output files statically
app.mount("/splats", StaticFiles(directory=str(OUTPUT_DIR)), name="splats")


@app.get("/")
async def root():
    return {
        "status": "ok",
        "message": "Photo to Splat API - POST /convert with an image",
    }


@app.post("/convert")
async def convert_image_to_splat(file: UploadFile = File(...)):
    """
    Convert an uploaded image to a 3D Gaussian Splat using SHARP.
    Returns the path to the generated .ply file.
    """
    # Validate file type
    if not file.content_type or not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="File must be an image")

    # Generate unique ID for this conversion
    job_id = str(uuid.uuid4())[:8]

    # Create temp directory for input/output
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir_path = Path(tmpdir)

        # Save uploaded image
        input_path = tmpdir_path / f"input_{job_id}.jpg"
        content = await file.read()
        with open(input_path, "wb") as f:
            f.write(content)

        # Output path for the splat
        output_dir = tmpdir_path / "output"
        output_dir.mkdir()

        try:
            # Run SHARP prediction
            # Note: SHARP auto-downloads the model on first run
            log(job_id, "Starting SHARP prediction...")
            log(job_id, f"Input: {input_path} ({len(content) / 1024:.1f} KB)")

            # Use Popen to stream output in real-time
            process = subprocess.Popen(
                ["sharp", "predict", "-i", str(input_path), "-o", str(output_dir)],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
            )

            # Stream output
            output_lines: list[str] = []
            assert process.stdout is not None
            for line in iter(process.stdout.readline, ""):
                line = line.strip()
                if line:
                    log(job_id, line)
                    output_lines.append(line)

            process.wait(timeout=300)  # 5 minute timeout

            if process.returncode != 0:
                error_output = "\n".join(output_lines)
                log(job_id, f"SHARP failed with code {process.returncode}")
                raise HTTPException(
                    status_code=500, detail=f"SHARP prediction failed: {error_output}"
                )

            log(job_id, "SHARP completed successfully")

            # Find the output .ply file
            ply_files = list(output_dir.glob("*.ply"))
            if not ply_files:
                raise HTTPException(
                    status_code=500, detail="No .ply file generated by SHARP"
                )

            # Copy to permanent output directory
            output_ply = ply_files[0]
            final_path = OUTPUT_DIR / f"{job_id}.ply"

            # Read and write to final location
            with open(output_ply, "rb") as src:
                with open(final_path, "wb") as dst:
                    dst.write(src.read())

            return {
                "success": True,
                "job_id": job_id,
                "splat_url": f"/splats/{job_id}.ply",
                "message": "Conversion complete",
            }

        except subprocess.TimeoutExpired:
            raise HTTPException(status_code=504, detail="Conversion timed out")
        except FileNotFoundError:
            raise HTTPException(
                status_code=500,
                detail="SHARP CLI not found. Install with: pip install -r requirements.txt && pip install git+https://github.com/apple/ml-sharp.git",
            )


@app.get("/splats/{job_id}.ply")
async def get_splat(job_id: str):
    """Download a generated splat file."""
    file_path = OUTPUT_DIR / f"{job_id}.ply"
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Splat not found")
    return FileResponse(
        file_path, media_type="application/octet-stream", filename=f"{job_id}.ply"
    )


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(app, host="0.0.0.0", port=8000)
